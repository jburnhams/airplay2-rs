# Section 69: pyatv Setup, Driver Scripts & Client Wrapper

## Dependencies
- **Section 64**: Subprocess Management Framework
- **Section 63**: Integration Test Strategy

## Overview

pyatv is a Python library and CLI tool for interacting with Apple TV and AirPlay devices. We use it as an external AirPlay client to test our receiver implementation — pyatv connects to our receiver and streams audio, allowing us to verify that our receiver correctly handles real client traffic from a completely independent implementation.

pyatv supports both AirPlay 1 (RAOP) and AirPlay 2 protocols and can stream audio files, control playback, and manage pairing. Unlike the Python receiver (which we already use to test our client), pyatv acts as a **sender/client**, which is the role we need to test our receiver.

## Key Challenge

pyatv is a Python library, not a standalone audio-streaming binary. We need custom Python driver scripts that use pyatv's API to:
1. Discover our receiver on the network (or connect to a known address).
2. Perform pairing if required.
3. Stream a known audio file (WAV or raw PCM).
4. Report success/failure back to the Rust test harness.

The driver scripts are the most complex part of this setup — they bridge pyatv's async Python API with our Rust test infrastructure.

---

## Tasks

### 69.1 pyatv Installation & Version Pinning

**Installation:**
```
pip install pyatv==0.15.x
```

Pin exact version in `tests/pyatv/requirements.txt`:
```
pyatv==0.15.1
aiofiles>=23.0
```

**Verify installation:**
```python
import pyatv
print(pyatv.__version__)
```

**System requirements:**
- Python 3.9+ (pyatv uses modern async features)
- `libffi`, `libssl` (for cryptography package that pyatv depends on)
- No audio hardware needed (pyatv streams from files)

**CLI tool:** pyatv installs `atvremote` CLI, useful for manual testing but we use the library API for automation.

**Uncertainties:**
- pyatv version compatibility — the API changes between minor versions. Pin exactly and test.
- pyatv's AirPlay audio streaming support is focused on RAOP (AirPlay 1). AP2 audio streaming via pyatv is experimental and may have limitations.
- pyatv uses `zeroconf` for mDNS which needs network interface configuration for loopback testing.

---

### 69.2 Audio Test File Generation

**File:** `tests/pyatv/generate_test_audio.py`

pyatv streams audio from files. We need to pre-generate WAV files with known sine wave content that matches what our Rust `TestSineSource` produces.

**Script functionality:**
1. Generate WAV files at standard test frequencies (440 Hz, 880 Hz, 1000 Hz).
2. Output: 16-bit signed, 44100 Hz, stereo.
3. Durations: 1s, 3s, 10s, 30s.
4. Store in `tests/pyatv/audio/`.
5. Also generate a stereo file with 440 Hz left / 880 Hz right for channel independence tests.

**File naming:** `sine_{frequency}hz_{duration}s_{sample_rate}.wav`

Examples:
- `sine_440hz_3s_44100.wav`
- `sine_880hz_10s_44100.wav`
- `stereo_440_880hz_3s_44100.wav`

**Implementation:**
```python
import wave, struct, math

def generate_sine_wav(path, freq, duration_s, sample_rate=44100):
    ...
```

**Note:** these files should be `.gitignore`d and regenerated by the test setup script, not committed to the repo (they're deterministic and can be large).

---

### 69.3 AP2 Driver Script

**File:** `tests/pyatv/driver_ap2.py`

This script uses pyatv to act as an AirPlay 2 client connecting to our receiver.

**Command-line interface:**
```
python3 driver_ap2.py \
    --host 127.0.0.1 \
    --port 7000 \
    --audio-file tests/pyatv/audio/sine_440hz_3s_44100.wav \
    --pin 3939 \
    --action stream \
    --output-json /tmp/result.json \
    [--timeout 30]
```

**Actions:**
- `discover` — discover the receiver and report its properties (name, features, protocols).
- `pair` — perform pairing only, report success/failure.
- `stream` — pair (if needed) and stream the audio file.
- `volume` — pair, stream briefly, change volume mid-stream.
- `metadata` — pair, stream, send metadata.
- `info` — connect and fetch device info.

**Output:** JSON file at `--output-json` path with:
```json
{
    "success": true,
    "action": "stream",
    "duration_ms": 3200,
    "protocol": "airplay2",
    "errors": [],
    "device_info": { ... },
    "streaming_stats": {
        "bytes_sent": 529200,
        "packets_sent": 150
    }
}
```

On failure:
```json
{
    "success": false,
    "action": "stream",
    "errors": ["Connection refused", "Pairing failed: wrong PIN"],
    "traceback": "..."
}
```

**Implementation skeleton:**

```python
import asyncio, json, argparse, sys
import pyatv
from pyatv.const import Protocol

async def main(args):
    result = {"success": False, "action": args.action, "errors": []}
    try:
        # Create configuration for the target device
        config = pyatv.interface.BaseConfig()
        config.add_service(...)  # Add AirPlay service at host:port

        # Connect
        atv = await pyatv.connect(config, loop=asyncio.get_event_loop())

        if args.action == "stream":
            # Pair if needed
            await atv.airplay.pair(pin=args.pin)
            # Stream audio
            await atv.stream.stream_file(args.audio_file)
            result["success"] = True

        await atv.close()
    except Exception as e:
        result["errors"].append(str(e))
        result["traceback"] = traceback.format_exc()

    with open(args.output_json, 'w') as f:
        json.dump(result, f, indent=2)

    sys.exit(0 if result["success"] else 1)
```

**Uncertainties:**
- pyatv's `stream_file` may not support all audio formats. Test with WAV first, then investigate raw PCM support.
- pyatv may try to discover the device via mDNS even when given a direct address. May need to construct a `pyatv.conf.AppleTV` config manually to bypass discovery.
- pyatv's pairing flow may differ from what Apple devices do. This is a good stress test for our receiver.
- Error messages from pyatv may not be granular enough for test assertions. Parse both the JSON output and stderr.

---

### 69.4 AP1/RAOP Driver Script

**File:** `tests/pyatv/driver_ap1.py`

Same structure as the AP2 driver but forces RAOP protocol.

**Key differences from AP2 driver:**
- Use `Protocol.RAOP` instead of `Protocol.AirPlay`.
- No HomeKit pairing — use password authentication if needed.
- Different service configuration (RAOP service type).

**Command-line interface:**
```
python3 driver_ap1.py \
    --host 127.0.0.1 \
    --port 5000 \
    --audio-file tests/pyatv/audio/sine_440hz_3s_44100.wav \
    --password "" \
    --action stream \
    --output-json /tmp/result.json
```

**Uncertainties:**
- pyatv's RAOP client support may be less mature than its AP2 support. Check pyatv docs for RAOP streaming limitations.
- RAOP typically involves RTSP ANNOUNCE → SETUP → RECORD flow which pyatv handles internally. Our receiver must respond correctly to each step.

---

### 69.5 PyAtvDriver Rust Wrapper

**File:** `tests/common/pyatv.rs`

**Struct: `PyAtvConfig`**

Fields:
- `host: String` — target receiver address (default: `"127.0.0.1"`)
- `port: u16` — target receiver port
- `protocol: PyAtvProtocol` — `AirPlay2` or `Raop`
- `audio_file: PathBuf` — WAV file to stream
- `pin: Option<String>` — pairing PIN (for AP2)
- `password: Option<String>` — AirPlay password (for AP1)
- `action: PyAtvAction` — what the driver should do
- `timeout: Duration` — max execution time

**Enum: `PyAtvProtocol`** — `AirPlay2`, `Raop`

**Enum: `PyAtvAction`** — `Discover`, `Pair`, `Stream`, `Volume(f32)`, `Metadata`, `Info`

**Struct: `PyAtvDriver`**

Fields:
- `handle: SubprocessHandle`
- `config: PyAtvConfig`
- `result_path: PathBuf` — path to JSON output file

Public methods:

**`async fn run(config: PyAtvConfig) -> Result<PyAtvResult, PyAtvError>`**

Steps:
1. Ensure test audio file exists, generate if not (call `generate_test_audio.py`).
2. Create temp file path for JSON output.
3. Select driver script based on `config.protocol`.
4. Build `SubprocessConfig`:
   - `command: "python3"`
   - `args: [driver_script_path, "--host", host, "--port", port, ...]`
   - `ready_pattern: ""` — no ready pattern; the script runs to completion.
   - Use `ready_strategy: ReadyStrategy::Delay(Duration::from_millis(500))` since driver scripts don't have a "ready" state.
5. Spawn and wait for exit (with timeout).
6. Read JSON output file.
7. Parse into `PyAtvResult`.

**`async fn stream_to(host: &str, port: u16, audio_file: &Path, protocol: PyAtvProtocol) -> Result<PyAtvResult, PyAtvError>`**

Convenience method — constructs config and calls `run()`.

**Struct: `PyAtvResult`**

Fields:
- `success: bool`
- `action: String`
- `duration: Duration`
- `errors: Vec<String>`
- `device_info: Option<serde_json::Value>`
- `streaming_stats: Option<StreamingStats>`

**Struct: `StreamingStats`**

Fields:
- `bytes_sent: u64`
- `packets_sent: u64`

**Enum: `PyAtvError`**

Variants:
- `ScriptFailed { exit_code: i32, errors: Vec<String> }`
- `Timeout { duration: Duration }`
- `OutputParseFailed { source: serde_json::Error }`
- `AudioFileNotFound { path: PathBuf }`
- `PythonNotFound`
- `PyAtvNotInstalled`

---

### 69.6 Environment Validation

**File:** `tests/common/pyatv.rs`

**Function: `async fn validate_pyatv_environment() -> Result<(), PyAtvError>`**

Checks before running any pyatv test:
1. `python3` is available.
2. `import pyatv` succeeds.
3. pyatv version matches expected.
4. Test audio files exist (or can be generated).

Call this in test setup. If it fails, skip tests with `#[ignore]` rather than failing.

**Function: `fn ensure_test_audio_files() -> Result<(), PyAtvError>`**

Run `generate_test_audio.py` to create all needed WAV files. Idempotent — skips if files already exist with correct size.

---

### 69.7 mDNS Considerations for Loopback

pyatv uses `zeroconf` for mDNS discovery. On loopback interfaces, mDNS may not work out of the box.

**Strategies:**
1. **Bypass discovery** (recommended for most tests) — construct the `pyatv.conf.AppleTV` config object directly with the known address and port, skipping mDNS.
2. **Configure zeroconf for loopback** — pass `--interface lo` or configure zeroconf to use the loopback interface. This may require patching the driver script.
3. **Run Avahi for service advertisement** — our receiver advertises via mDNS, pyatv discovers it. This exercises the full discovery path but is more complex.

For most tests, strategy 1 is sufficient. Strategy 3 should be used for discovery-specific tests only.

---

## Test Cases

| ID | Test | Verifies |
|---|---|---|
| 69-T1 | `test_pyatv_installed` | pyatv importable and correct version |
| 69-T2 | `test_audio_files_generated` | WAV files created at expected paths with correct format |
| 69-T3 | `test_driver_ap2_help` | AP2 driver script runs with `--help` without error |
| 69-T4 | `test_driver_ap1_help` | AP1 driver script runs with `--help` without error |
| 69-T5 | `test_driver_bad_host` | Driver script returns JSON error for unreachable host |
| 69-T6 | `test_driver_output_json_format` | JSON output has required fields (success, action, errors) |
| 69-T7 | `test_pyatv_result_parsing` | Rust code correctly parses driver JSON output |
| 69-T8 | `test_environment_validation` | `validate_pyatv_environment()` passes on CI |

---

## Acceptance Criteria

- [ ] pyatv installs from requirements.txt without error on Ubuntu and macOS
- [ ] Test audio files generated deterministically
- [ ] AP2 driver script can connect to a running receiver and stream audio
- [ ] AP1 driver script can connect to a running receiver and stream audio
- [ ] JSON output from driver scripts is parseable by Rust wrapper
- [ ] Errors produce clear JSON with actionable error messages
- [ ] Environment validation skips tests gracefully when pyatv is not available

---

## References

- [pyatv documentation](https://pyatv.dev/)
- [pyatv API reference](https://pyatv.dev/api/)
- [pyatv RAOP support](https://pyatv.dev/documentation/raop/)
- [pyatv AirPlay support](https://pyatv.dev/documentation/airplay/)
- `tests/common/subprocess.rs` — Section 64 subprocess framework
- `tests/common/python_receiver.rs` — existing Python subprocess pattern
